#include <vector>

#include <node.h>
#include <nan.h>
#include <glibmm.h>
#include <giomm.h>

using namespace v8;
using namespace std;
using namespace Glib;
using namespace Gio;

/**
 * Convert a vector of ustrings to a V8 array
 */
Local<Array> vectorToArray(vector<ustring> list) {
    Local<Array> arr = NanNew<Array>();
    int length(list.size()), i;
    
    for (i = 0; i < length; i += 1) {
        arr->Set(
            NanNew<Number>(i),
            NanNew<String>(list[i])
        );
    }
    
    return arr;
}

/**
 * Convert a V8 array to a vector of ustrings
 */
vector<ustring> arrayToVector(Local<Array> arr) {
    vector<ustring> list;
    int length(arr->Length()), i;
    
    for (i = 0; i < length; i += 1) {
        String::Utf8Value val(arr->Get(
            NanNew<Number>(i)
        ));
        
        list.push_back(ustring(*val));
    }
    
    return list;
}

/**
 * Get a V8 representation of an attribute's value
 */
v8::Local<v8::Value> getAttributeValue(RefPtr<FileInfo> info, string key) {
    FileAttributeType attrType(info->get_attribute_type(key));
    
    switch (attrType) {
        case FILE_ATTRIBUTE_TYPE_STRING:
            return NanNew<String>(info->get_attribute_string(key));
        
        case FILE_ATTRIBUTE_TYPE_STRINGV:
            return vectorToArray(info->get_attribute_strings(key));
        
        case FILE_ATTRIBUTE_TYPE_BYTE_STRING:
            return NanNew<String>(info->get_attribute_byte_string(key));
        
        case FILE_ATTRIBUTE_TYPE_BOOLEAN:
            return NanNew<Boolean>(info->get_attribute_boolean(key));
        
        case FILE_ATTRIBUTE_TYPE_UINT64:
        case FILE_ATTRIBUTE_TYPE_INT64:
            return NanNew<String>(info->get_attribute_as_string(key));
        
        case FILE_ATTRIBUTE_TYPE_UINT32:
            return NanNew<Number>(info->get_attribute_uint32(key));
        
        case FILE_ATTRIBUTE_TYPE_INT32:
            return NanNew<Number>(info->get_attribute_int32(key));
        
        case FILE_ATTRIBUTE_TYPE_OBJECT:
            return NanNew<String>(info->get_attribute_as_string(key));
        
        default:
            return NanUndefined();
    }
}

/**
 * Get a file's list of attributes
 */
NAN_METHOD(GetAttributes) {
    NanScope();
    
    String::Utf8Value path(args[0]);
    RefPtr<File> file = File::create_for_path(string(*path));
    RefPtr<FileInfo> info;
    
    try {
        info = file->query_info();
    } catch (Gio::Error const &e) {
        NanThrowError(e.what().c_str(), e.code());
        NanReturnUndefined();
    }
    
    // use the unwrapped method because we want to pass NULL
    // and not a string. See bad implementation in glibmm:
    // https://github.com/GNOME/glibmm/tree/master/gio/src/fileinfo.hg#L102
    vector<ustring> attrs(Glib::StringArrayHandle(
        g_file_info_list_attributes(info->gobj(), NULL),
        Glib::OWNERSHIP_DEEP
    ));
    
    Local<v8::Object> obj(NanNew<v8::Object>());
    int length(attrs.size()), i;
    
    for (i = 0; i < length; i++) {
        obj->Set(
            NanNew<String>(attrs[i]),
            getAttributeValue(info, attrs[i])
        );
    }
    
    NanReturnValue(obj);
}

/**
 * Get a file's attribute
 */
NAN_METHOD(GetAttribute) {
    NanScope();
    
    String::Utf8Value path(args[0]);
    String::Utf8Value attr(args[1]);
    
    RefPtr<File> file = File::create_for_path(string(*path));
    RefPtr<FileInfo> info;
    
    try {
        info = file->query_info();
    } catch (Gio::Error const &e) {
        NanThrowError(e.what().c_str(), e.code());
        NanReturnUndefined();
    }
    
    NanReturnValue(getAttributeValue(info, string(*attr)));
}

/**
 * Set a file's attribute
 */
NAN_METHOD(SetAttribute) {
    NanScope();
    
    bool did_change(false);
    String::Utf8Value path(args[0]);
    String::Utf8Value attr(args[1]);
    
    RefPtr<File> file = File::create_for_path(string(*path));
    RefPtr<FileInfo> info;
    
    try {
        info = file->query_info();
    } catch (Gio::Error const &e) {
        NanThrowError(e.what().c_str(), e.code());
        NanReturnUndefined();
    }
    
    if (args[2]->IsArray()) {
        info->set_attribute_strings(
            string(*attr),
            arrayToVector(Local<Array>::Cast(args[2]))
        );
        
        did_change = true;
    }
    
    if (args[2]->IsString()) {
        String::Utf8Value val(args[2]);
        
        info->set_attribute_string(
            string(*attr),
            string(*val)
        );
        
        did_change = true;
    }
    
    if (args[2]->IsNumber()) {
        gint32 val(args[2]->Int32Value());
        
        info->set_attribute_int32(
            string(*attr),
            val
        );
        
        did_change = true;
    }
    
    if (args[2]->IsBoolean()) {
        info->set_attribute_boolean(
            string(*attr),
            args[2]->BooleanValue()
        );
        
        did_change = true;
    }
    
    if (did_change) {
        try {
            file->set_attributes_from_info(info);
        } catch (Gio::Error const &e) {
            // errors here are not relevant, they are thrown
            // because we are re-setting the whole info
            // object, and that object contains non-writtable props
        }
    } else {
        NanThrowError("Unrecognized argument type");
    }
    
    NanReturnUndefined();
}
